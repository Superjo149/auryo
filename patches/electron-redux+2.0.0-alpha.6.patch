diff --git a/node_modules/electron-redux/lib/electron-redux.js b/node_modules/electron-redux/lib/electron-redux.js
index 6e3210b..1605716 100644
--- a/node_modules/electron-redux/lib/electron-redux.js
+++ b/node_modules/electron-redux/lib/electron-redux.js
@@ -93,6 +93,8 @@ const validateAction = (action, // Actions that we should never replay across st
 denyList = [/^@@/, /^redux-form/]) => {
   var _action$meta;
 
+  console.log(isFSA(action), action);
+
   return isFSA(action) && ((_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : _action$meta.scope) !== 'local' && denyList.every(rule => !rule.test(action.type));
 };
 
@@ -158,7 +160,31 @@ const mainStateSyncEnhancer = (options = defaultMainOptions) => createStore => {
   preventDoubleInitialization();
   const middleware = createMiddleware(options);
   return (reducer, state) => {
-    return createStore(reducer, state, redux.applyMiddleware(middleware));
+    const store = createStore(reducer, state);
+
+    electron.ipcMain.handle(IPCEvents.INIT_STATE_ASYNC, async () => {
+      return JSON.stringify(store.getState(), options.serializer);
+    });
+    electron.ipcMain.on(IPCEvents.INIT_STATE, event => {
+      event.returnValue = JSON.stringify(store.getState(), options.serializer);
+    }); // When receiving an action from a renderer
+
+    electron.ipcMain.on(IPCEvents.ACTION, (event, action) => {
+      const localAction = stopForwarding(action);
+      store.dispatch(localAction); // Forward it to all of the other renderers
+
+      electron.webContents.getAllWebContents().forEach(contents => {
+        // Ignore the renderer that sent the action and chromium devtools
+        if (contents.id !== event.sender.id && !contents.getURL().startsWith('devtools://')) {
+          contents.send(IPCEvents.ACTION, localAction);
+        }
+      });
+    });
+    
+    return {
+      ...store,
+      // dispatch: middleware(store)(store.dispatch)
+    }
   };
 };
 
@@ -211,7 +237,9 @@ const createMiddleware$1 = options => store => {
     store.dispatch(stopForwarding(action));
   });
   return next => action => {
+    console.log(validateAction(action, options.denyList), action);
     if (validateAction(action, options.denyList)) {
+      console.log("DISPATCH LOCAL ACTIO",action);
       electron.ipcRenderer.send(IPCEvents.ACTION, action);
     }
 
@@ -231,7 +259,7 @@ const rendererStateSyncEnhancer = (options = defaultRendererOptions) => createSt
   preventDoubleInitialization();
   return (reducer, state) => {
     const initialState = options.lazyInit ? state : fetchInitialState(options);
-    const store = createStore(options.lazyInit ? withStoreReplacer(reducer) : reducer, initialState, redux.applyMiddleware(createMiddleware$1(options)));
+    const store = createStore(options.lazyInit ? withStoreReplacer(reducer) : reducer, initialState);
 
     if (options.lazyInit) {
       fetchInitialStateAsync(options, asyncState => {
@@ -242,11 +270,35 @@ const rendererStateSyncEnhancer = (options = defaultRendererOptions) => createSt
     // immediately it's fine, but even assigning it to a constant and returning
     // will make it freak out. We fix this with the line below the return.
 
+    electron.ipcRenderer.on(IPCEvents.ACTION, (_, action) => {
+      store.dispatch(stopForwarding(action));
+    });
+
 
-    return store; // TODO: this needs some ❤️
+    return {
+      ...store,
+      // dispatch: createMiddleware$1(options)(store)(store.dispatch)
+    } // TODO: this needs some ❤️
   };
 };
 
+const forwardAction = next => action => {
+  if(validateAction(action, options.denyList)){
+    if (process.type === "browser"){
+      electron.webContents.getAllWebContents().forEach(contents => {
+        // Ignore chromium devtools
+        if (contents.getURL().startsWith('devtools://')) return;
+        contents.send(IPCEvents.ACTION, action);
+      });
+    } else if(process.type === "renderer"){
+      electron.ipcRenderer.send(IPCEvents.ACTION, action);
+    }
+  }
+
+  return next(action);
+}
+
 exports.mainStateSyncEnhancer = mainStateSyncEnhancer;
 exports.rendererStateSyncEnhancer = rendererStateSyncEnhancer;
 exports.stopForwarding = stopForwarding;
+exports.forwardAction = forwardAction;
